/*
CUP specification for loliccompiler by RobbinNi
*/

package parser;

import lexer.Yylex;

import java.io.Reader;

/* Preliminaries to set up and use the scanner. */

parser code {:
    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("\tParsing error");
    	if (info instanceof java_cup.runtime.Symbol) {
    		java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;

   			if (s.left >= 0) {
   				m.append(" in line " + (s.left +1 ));
   				if (s.right >= 0) { m.append(", column " + (s.right + 1));
   				}
   			}
   		}
   		m.append(" : " + message);
   		System.err.println(m);
   	}

   	public Parser(Reader input) {
   		this(new Yylex(input));
   	}
:};

/* Terminals */

/* Operators */
terminal	PARAL, PARAR, COLON, COMMA, ASSIGN, CURLYL, CURLYR, SQUARL, SQUARR, MUL, OR, XOR, ADRESS, LESS, GREATER, ADD, SUB, DIV, MOD, TILDE, NOT, DOT;
terminal	OR_OP, AND_OP, EQ_OP, NE_OP, LE_OP, GE_OP, SHL_OP, SHR_OP, INC_OP, DEC_OP, PTR_OP;
terminal	MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, XOR_ASSIGN, OR_ASSIGN, AND_ASSIGN;

/* Identifier and Constants */
terminal			IDENTIFIER;
terminal Integer	INTEGER;
terminal Char		CHARACTER;
terminal String		STRING;

/* Keywords */
terminal			VOID, CHAR, INT;
terminal			STRUCT, UNION;
terminal			IF, ELSE, WHILE, FOR, CONTINUE, BREAK, RETURN;
terminal			SIZEOF;

/* Non-terminals */

/* Top level */
non terminal program, external_definition, declaration, function_definition, parameter_list, plain_declaration, declarator, declarator_list, array_dimensions,
			 plain_declarator, asterisks, init_declarator_list, init_declarator, initializer, initializer_list, type_specifier, struct_or_union,
			 struct_or_union_definition, field_list, declaration_list;

/* Statements */
non terminal statement, statement_list, expression_statement, compound_statement, selection_statement, iteration_statement, jump_statement;

/* Expressions */
non terminal expression, assignment_expression, assignment_operator, constant_expression, logical_or_expression, logical_and_expression,
			 inclusive_or_expression, exclusive_or_expression, and_expression, equality_expression, equality_operator, relational_expression,
			 relational_operator, shift_expression,	shift_operator, additive_expression, additive_operator, multiplicative_expression,
			 multiplicative_operator, cast_expression, type_name, unary_expression, unary_operator, postfix_expression, postfix,
			 argument_list, primary_expression, constant;

/* Precedences */

precedence nonassoc ELSE;

/* The grammar */

start with program;

program ::= 	external_definition
			| 	program external_definition
			;

external_definition ::= 	declaration
						|	function_definition
						;

declaration ::=		type_specifier COLON
				|	type_specifier init_declarator_list COLON
				;

declaration_list ::= 	declaration
					|	declaration_list declaration
					;

function_definition ::=		type_specifier plain_declarator PARAL PARAR compound_statement
						|	type_specifier plain_declarator PARAL parameter_list PARAR compound_statement
						;

parameter_list ::=		plain_declaration
					|	parameter_list COMMA plain_declaration
					;

plain_declaration ::=		type_specifier declarator
						;

declarator ::=		plain_declarator
				|	plain_declarator PARAL PARAR
				|	plain_declarator PARAL parameter_list PARAR
				|	plain_declarator array_dimensions
				;

declarator_list ::=		declarator
					|	declarator_list COMMA declarator
					;

array_dimensions ::=	SQUARL constant_expression SQUARR
					|	array_dimensions SQUARL constant_expression SQUARR
					;

plain_declarator ::=		IDENTIFIER
						|	asterisks IDENTIFIER
						;

asterisks ::= 		MUL
				|	asterisks MUL
				;

init_declarator_list ::=	init_declarator
						|	init_declarator_list COMMA init_declarator
						;

init_declarator	::=		declarator
					|	declarator ASSIGN initializer
					;

initializer	::=		assignment_expression
				|	CURLYL initializer_list CURLYR
				;

initializer_list ::=	initializer
					|	initializer_list COMMA initializer
					;

type_specifier ::=		VOID
					|	INT
					|	CHAR
					|	struct_or_union	IDENTIFIER
					|	struct_or_union struct_or_union_definition
					;

struct_or_union	::=		STRUCT
					|	UNION
					;

struct_or_union_definition ::=		IDENTIFIER CURLYL field_list CURLYR
								|	CURLYL field_list CURLYR
								;

field_list ::=		type_specifier declarator_list COLON
				|	field_list type_specifier declarator_list COLON
				;


statement ::=		expression_statement
				|	compound_statement
				|	selection_statement
				|	iteration_statement
				|	jump_statement
				;

statement_list ::= 		statement
					|	statement_list statement
					;

expression_statement ::=	expression COLON
						|	COLON
						;

compound_statement ::=		CURLYL declaration_list statement_list CURLYR
						|	CURLYL statement_list CURLYR
						|	CURLYL declaration_list CURLYR
						|	CURLYL CURLYR
						;

selection_statement ::=		IF PARAL expression PARAR statement
						|	IF PARAL expression PARAR statement ELSE statement
						;

iteration_statement ::=		WHILE PARAL expression PARAR statement
						|	FOR PARAL expression_statement expression_statement PARAR statement
						|	FOR PARAL expression_statement expression_statement expression PARAR statement
						;

jump_statement ::=		CONTINUE COLON
					|	BREAK COLON
					|	RETURN COLON
					|	RETURN expression COLON
					;


expression ::=		assignment_expression
				|	expression COMMA assignment_expression
				;

assignment_expression ::=		logical_or_expression
							|	unary_expression assignment_operator assignment_expression
							;

assignment_operator ::=		ASSIGN
						|	MUL_ASSIGN
						|	DIV_ASSIGN
						|	MOD_ASSIGN
						|	ADD_ASSIGN
						|	SUB_ASSIGN
						|	SHL_ASSIGN
						|	SHR_ASSIGN
						|	AND_ASSIGN
						|	OR_ASSIGN
						|	XOR_ASSIGN
						;

constant_expression ::=		logical_or_expression
						;

logical_or_expression ::=		logical_and_expression
							|	logical_or_expression OR_OP logical_and_expression
							;

logical_and_expression ::=		inclusive_or_expression
							|	logical_and_expression AND_OP inclusive_or_expression
							;

inclusive_or_expression ::=		exclusive_or_expression
							|	inclusive_or_expression OR exclusive_or_expression
							;

exclusive_or_expression ::=		and_expression
							|	exclusive_or_expression XOR and_expression
							;

and_expression ::=		equality_expression
					|	and_expression ADRESS equality_expression
					;

equality_expression ::=		relational_expression
						|	equality_expression equality_operator relational_expression
						;

equality_operator ::=		EQ_OP
						|	NE_OP
						;

relational_expression ::=		shift_expression
							|	relational_expression relational_operator shift_expression
							;

relational_operator ::= 	LESS
						|	GREATER
						|	LE_OP
						|	GE_OP
						;

shift_expression ::=	additive_expression
					|	shift_expression shift_operator additive_expression
					;

shift_operator ::=		SHL_OP
					|	SHR_OP
					;

additive_expression ::=		multiplicative_expression
						|	additive_expression additive_operator multiplicative_expression
						;

additive_operator ::=		ADD
						|	SUB
						;

multiplicative_expression ::=		cast_expression
								|	multiplicative_expression multiplicative_operator cast_expression
								;

multiplicative_operator ::=		MUL
							|	DIV
							|	MOD
							;

cast_expression ::=		unary_expression
					|	PARAL type_name PARAR cast_expression
					;

type_name ::=		type_specifier
				|	type_specifier asterisks
				;

unary_expression ::=		postfix_expression
						|	INC_OP unary_expression
						|	DEC_OP unary_expression
						|	unary_operator cast_expression
						|	SIZEOF unary_expression
						|	SIZEOF PARAL type_name PARAR
						;

unary_operator ::=		ADRESS
					|	MUL
					|	ADD
					|	SUB
					|	TILDE
					|	NOT
					;

postfix_expression ::=		primary_expression
						|	postfix_expression postfix
						;

postfix ::=		SQUARL expression SQUARR
			|	PARAL PARAR
			|	PARAL argument_list PARAR
			|	DOT IDENTIFIER
			|	PTR_OP IDENTIFIER
			|	INC_OP
			|	DEC_OP
			;

argument_list ::=		assignment_expression
					|	argument_list COMMA assignment_expression
					;

primary_expression	::=		IDENTIFIER
						|	constant
						|	STRING
						|	PARAL expression PARAR
						;

constant ::=		INTEGER
				|	CHARACTER
				;
